// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: presentation_query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createPresentation = `-- name: CreatePresentation :one
INSERT INTO presentations
  (currentpollindex)
VALUES
  ($1)
RETURNING id
`

func (q *Queries) CreatePresentation(ctx context.Context, currentpollindex sql.NullInt32) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPresentation, currentpollindex)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createPresentationAndPolls = `-- name: CreatePresentationAndPolls :one
WITH presentations_cte AS (
INSERT INTO presentations
  (id, currentpollindex)
VALUES
  (uuid_generate_v4(), 1)
RETURNING id
),
data_cte AS
(
  SELECT
  to_jsonb($1
::jsonb) AS data
),
polls_cte AS
(
INSERT INTO polls
  (question, presentationid, pollindex)
SELECT
  (arr.elem ->> 'question')
::TEXT AS question,
    pc.id AS presentationid,
    arr.idx AS pollindex
  FROM presentations_cte pc, data_cte dc,
    jsonb_array_elements
(dc.data)
WITH ORDINALITY AS arr
(elem, idx)
  RETURNING id, pollindex
),
options_cte AS
(
INSERT INTO options
  (pollid, optionkey, optionvalue)
SELECT
  pc.id,
  (o ->> 'key')
::TEXT AS optionkey,
(o ->> 'value')::TEXT AS optionvalue
  FROM polls_cte pc, data_cte dc,
    LATERAL jsonb_array_elements
(dc.data -> pc.pollindex - 1 -> 'options') AS o
  RETURNING id,pollid
)

SELECT id
FROM presentations_cte
`

func (q *Queries) CreatePresentationAndPolls(ctx context.Context, dollar_1 json.RawMessage) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPresentationAndPolls, dollar_1)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getPollVotes = `-- name: GetPollVotes :many
SELECT
  votes.optionkey,
  votes.clientid
FROM votes
  JOIN polls ON votes.pollid = polls.id
  JOIN presentations ON polls.presentationID = presentations.id
WHERE presentations.id = $1
  AND polls.id = $2
ORDER BY votes.optionkey
`

type GetPollVotesParams struct {
	ID   uuid.UUID `db:"id"`
	ID_2 uuid.UUID `db:"id_2"`
}

type GetPollVotesRow struct {
	Optionkey string `db:"optionkey"`
	Clientid  string `db:"clientid"`
}

func (q *Queries) GetPollVotes(ctx context.Context, arg GetPollVotesParams) ([]GetPollVotesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPollVotes, arg.ID, arg.ID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPollVotesRow
	for rows.Next() {
		var i GetPollVotesRow
		if err := rows.Scan(&i.Optionkey, &i.Clientid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPollsCount = `-- name: GetPollsCount :one
SELECT COUNT(*) AS polls_count
FROM polls
WHERE presentationid = $1
`

func (q *Queries) GetPollsCount(ctx context.Context, presentationid uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPollsCount, presentationid)
	var polls_count int64
	err := row.Scan(&polls_count)
	return polls_count, err
}

const getPresentation = `-- name: GetPresentation :one
SELECT id, currentpollindex
FROM presentations
WHERE id = $1
`

func (q *Queries) GetPresentation(ctx context.Context, id uuid.UUID) (Presentation, error) {
	row := q.db.QueryRowContext(ctx, getPresentation, id)
	var i Presentation
	err := row.Scan(&i.ID, &i.Currentpollindex)
	return i, err
}

const getPresentationCurrentPoll = `-- name: GetPresentationCurrentPoll :one
SELECT
  p.id AS id,
  p.question AS question,
  (
    SELECT jsonb_agg(jsonb_build_object(
      'optionkey', o.optionkey,
      'optionvalue', o.optionvalue
    )) AS options
  FROM options o
  WHERE o.pollid = p.id
  ) AS options
FROM polls p
WHERE p.presentationid = $1 and p.pollindex=(SELECT currentpollindex
  FROM presentations
  WHERE id=$1)
`

type GetPresentationCurrentPollRow struct {
	ID       uuid.UUID       `db:"id"`
	Question string          `db:"question"`
	Options  json.RawMessage `db:"options"`
}

func (q *Queries) GetPresentationCurrentPoll(ctx context.Context, presentationid uuid.UUID) (GetPresentationCurrentPollRow, error) {
	row := q.db.QueryRowContext(ctx, getPresentationCurrentPoll, presentationid)
	var i GetPresentationCurrentPollRow
	err := row.Scan(&i.ID, &i.Question, &i.Options)
	return i, err
}

const moveBackwardToPreviousPoll = `-- name: MoveBackwardToPreviousPoll :one
WITH updated_polls_cte AS(
   UPDATE presentations
	SET currentpollindex = GREATEST(currentpollindex - 1, (
	  SELECT min(pollindex)
	  FROM polls
	  WHERE polls.presentationid = $1
	))
	WHERE id = $1
   RETURNING id, currentpollindex
)
SELECT
  p.id AS id,
  p.question AS question,
  (
    SELECT jsonb_agg(jsonb_build_object(
      'optionkey', o.optionkey,
      'optionvalue', o.optionvalue
    )) AS options
  FROM options o
  INNER JOIN polls p ON o.pollid = p.id
  WHERE p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
  ) AS options
FROM polls p
INNER JOIN updated_polls_cte upc ON p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
`

type MoveBackwardToPreviousPollRow struct {
	ID       uuid.UUID       `db:"id"`
	Question string          `db:"question"`
	Options  json.RawMessage `db:"options"`
}

func (q *Queries) MoveBackwardToPreviousPoll(ctx context.Context, presentationid uuid.UUID) (MoveBackwardToPreviousPollRow, error) {
	row := q.db.QueryRowContext(ctx, moveBackwardToPreviousPoll, presentationid)
	var i MoveBackwardToPreviousPollRow
	err := row.Scan(&i.ID, &i.Question, &i.Options)
	return i, err
}

const moveForwardToNextPoll = `-- name: MoveForwardToNextPoll :one
WITH updated_polls_cte AS(
   UPDATE presentations
	SET currentpollindex = LEAST(currentpollindex + 1, (
	  SELECT max(pollindex)
	  FROM polls
	  WHERE polls.presentationid = $1
	))
	WHERE id = $1
   RETURNING id, currentpollindex
)
SELECT
  p.id AS id,
  p.question AS question,
  (
    SELECT jsonb_agg(jsonb_build_object(
      'optionkey', o.optionkey,
      'optionvalue', o.optionvalue
    )) AS options
  FROM options o
  INNER JOIN polls p ON o.pollid = p.id
  WHERE p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
  ) AS options
FROM polls p
INNER JOIN updated_polls_cte upc ON p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
`

type MoveForwardToNextPollRow struct {
	ID       uuid.UUID       `db:"id"`
	Question string          `db:"question"`
	Options  json.RawMessage `db:"options"`
}

func (q *Queries) MoveForwardToNextPoll(ctx context.Context, presentationid uuid.UUID) (MoveForwardToNextPollRow, error) {
	row := q.db.QueryRowContext(ctx, moveForwardToNextPoll, presentationid)
	var i MoveForwardToNextPollRow
	err := row.Scan(&i.ID, &i.Question, &i.Options)
	return i, err
}
