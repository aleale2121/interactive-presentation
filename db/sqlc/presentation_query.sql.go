// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: presentation_query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createPresentation = `-- name: CreatePresentation :one
INSERT INTO presentations
  (currentpollindex)
VALUES
  ($1)
RETURNING id
`

func (q *Queries) CreatePresentation(ctx context.Context, currentpollindex sql.NullInt32) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPresentation, currentpollindex)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createPresentationAndPolls = `-- name: CreatePresentationAndPolls :one
WITH presentations_cte AS (
INSERT INTO presentations
  (id, currentpollindex)
VALUES
  (uuid_generate_v4(), 0)
RETURNING id
),
data_cte AS
(
  SELECT
  to_jsonb($1
::jsonb) AS data
),
polls_cte AS
(
INSERT INTO polls
  (question, presentationid, pollindex)
SELECT
  (arr.elem ->> 'question')
::TEXT AS question,
    pc.id AS presentationid,
    arr.idx AS pollindex
  FROM presentations_cte pc, data_cte dc,
    jsonb_array_elements
(dc.data)
WITH ORDINALITY AS arr
(elem, idx)
  RETURNING id, pollindex
),
options_cte AS
(
INSERT INTO options
  (pollid, optionkey, optionvalue)
SELECT
  pc.id,
  (o ->> 'key')
::TEXT AS optionkey,
(o ->> 'value')::TEXT AS optionvalue
  FROM polls_cte pc, data_cte dc,
    LATERAL jsonb_array_elements
(dc.data -> pc.pollindex - 1 -> 'options') AS o
  RETURNING id,pollid
)

SELECT id
FROM presentations_cte
`

func (q *Queries) CreatePresentationAndPolls(ctx context.Context, dollar_1 json.RawMessage) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPresentationAndPolls, dollar_1)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getPollVotes = `-- name: GetPollVotes :many
SELECT
  votes.optionkey as "key",
  votes.clientid as "client_id"
FROM votes
  JOIN polls ON votes.pollid = polls.id
  JOIN presentations ON polls.presentationID = presentations.id
WHERE presentations.id = $1
  AND polls.id = $2
ORDER BY votes.optionkey
`

type GetPollVotesParams struct {
	PresentationID uuid.UUID `db:"presentation_id"`
	PollID         uuid.UUID `db:"poll_id"`
}

type GetPollVotesRow struct {
	Key      string `db:"key"`
	ClientID string `db:"client_id"`
}

func (q *Queries) GetPollVotes(ctx context.Context, arg GetPollVotesParams) ([]GetPollVotesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPollVotes, arg.PresentationID, arg.PollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPollVotesRow
	for rows.Next() {
		var i GetPollVotesRow
		if err := rows.Scan(&i.Key, &i.ClientID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPollsByPresentationID = `-- name: GetPollsByPresentationID :many
SELECT
  p.id AS poll_id,
  p.question,
  jsonb_agg(jsonb_build_object(
        'optionKey', o.optionKey,
        'optionValue', o.optionValue
    )) AS options
FROM
  polls p
  JOIN
  options o ON p.id = o.pollID
WHERE
    p.presentationID = $1
GROUP BY
    p.id, p.question, p.pollIndex, p.createdAt
`

type GetPollsByPresentationIDRow struct {
	PollID   uuid.UUID       `db:"poll_id"`
	Question string          `db:"question"`
	Options  json.RawMessage `db:"options"`
}

func (q *Queries) GetPollsByPresentationID(ctx context.Context, presentationid uuid.UUID) ([]GetPollsByPresentationIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getPollsByPresentationID, presentationid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPollsByPresentationIDRow
	for rows.Next() {
		var i GetPollsByPresentationIDRow
		if err := rows.Scan(&i.PollID, &i.Question, &i.Options); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPresentation = `-- name: GetPresentation :one
SELECT id, currentpollindex
FROM presentations
WHERE id = $1
`

func (q *Queries) GetPresentation(ctx context.Context, id uuid.UUID) (Presentation, error) {
	row := q.db.QueryRowContext(ctx, getPresentation, id)
	var i Presentation
	err := row.Scan(&i.ID, &i.Currentpollindex)
	return i, err
}

const getPresentationAndPoll = `-- name: GetPresentationAndPoll :one
SELECT 
  pr.id as presentation_id,
  pr.currentpollindex,
  pl.id as poll_id,
  pl.question as question,
  pl.pollindex
FROM
  presentations as pr JOIN polls as pl ON pr.id=pl.presentationid
WHERE 
  pr.id=$1 AND pl.id=$2
`

type GetPresentationAndPollParams struct {
	PresentationID uuid.UUID `db:"presentation_id"`
	PollID         uuid.UUID `db:"poll_id"`
}

type GetPresentationAndPollRow struct {
	PresentationID   uuid.UUID     `db:"presentation_id"`
	Currentpollindex sql.NullInt32 `db:"currentpollindex"`
	PollID           uuid.UUID     `db:"poll_id"`
	Question         string        `db:"question"`
	Pollindex        int32         `db:"pollindex"`
}

func (q *Queries) GetPresentationAndPoll(ctx context.Context, arg GetPresentationAndPollParams) (GetPresentationAndPollRow, error) {
	row := q.db.QueryRowContext(ctx, getPresentationAndPoll, arg.PresentationID, arg.PollID)
	var i GetPresentationAndPollRow
	err := row.Scan(
		&i.PresentationID,
		&i.Currentpollindex,
		&i.PollID,
		&i.Question,
		&i.Pollindex,
	)
	return i, err
}

const getPresentationCurrentPoll = `-- name: GetPresentationCurrentPoll :one
SELECT
  p.id AS id,
  p.question AS question,
  (
    SELECT jsonb_agg(jsonb_build_object(
      'optionkey', o.optionkey,
      'optionvalue', o.optionvalue
    )) AS options
  FROM options o
  WHERE o.pollid = p.id
  ) AS options
FROM polls p
WHERE p.presentationid = $1 and p.pollindex=(SELECT currentpollindex
  FROM presentations
  WHERE id=$1)
`

type GetPresentationCurrentPollRow struct {
	ID       uuid.UUID       `db:"id"`
	Question string          `db:"question"`
	Options  json.RawMessage `db:"options"`
}

func (q *Queries) GetPresentationCurrentPoll(ctx context.Context, presentationid uuid.UUID) (GetPresentationCurrentPollRow, error) {
	row := q.db.QueryRowContext(ctx, getPresentationCurrentPoll, presentationid)
	var i GetPresentationCurrentPollRow
	err := row.Scan(&i.ID, &i.Question, &i.Options)
	return i, err
}

const moveBackwardToPreviousPoll = `-- name: MoveBackwardToPreviousPoll :one
WITH updated_polls_cte AS(
UPDATE presentations
	SET currentpollindex = GREATEST(currentpollindex - 1, (
	  SELECT min(pollindex)
FROM polls
WHERE polls.presentationid = $1
	))
	WHERE id = $1
RETURNING id, currentpollindex
)
SELECT
  p.id AS id,
  p.question AS question,
  (
    SELECT jsonb_agg(jsonb_build_object(
      'optionkey', o.optionkey,
      'optionvalue', o.optionvalue
    )) AS options
  FROM options o
    INNER JOIN polls p ON o.pollid = p.id
  WHERE p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
  ) AS options
FROM polls p
  INNER JOIN updated_polls_cte upc ON p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
`

type MoveBackwardToPreviousPollRow struct {
	ID       uuid.UUID       `db:"id"`
	Question string          `db:"question"`
	Options  json.RawMessage `db:"options"`
}

func (q *Queries) MoveBackwardToPreviousPoll(ctx context.Context, presentationid uuid.UUID) (MoveBackwardToPreviousPollRow, error) {
	row := q.db.QueryRowContext(ctx, moveBackwardToPreviousPoll, presentationid)
	var i MoveBackwardToPreviousPollRow
	err := row.Scan(&i.ID, &i.Question, &i.Options)
	return i, err
}

const moveForwardToNextPoll = `-- name: MoveForwardToNextPoll :one
WITH updated_polls_cte AS(
UPDATE presentations
	SET currentpollindex = currentpollindex + 1
	WHERE presentations.id = $1 AND currentpollindex + 1 <= (
    SELECT count(*)
  FROM polls
  WHERE presentationid = $1
  )
RETURNING id, currentpollindex
)
SELECT
  p.id AS id,
  p.question AS question,
  (
    SELECT jsonb_agg(jsonb_build_object(
      'optionkey', o.optionkey,
      'optionvalue', o.optionvalue
    )) AS options
  FROM options o
    INNER JOIN polls p ON o.pollid = p.id
  WHERE p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
  ) AS options
FROM polls p
  INNER JOIN updated_polls_cte upc ON p.presentationid = upc.id AND p.pollindex=upc.currentpollindex
WHERE upc.id IS NOT NULL
`

type MoveForwardToNextPollRow struct {
	ID       uuid.UUID       `db:"id"`
	Question string          `db:"question"`
	Options  json.RawMessage `db:"options"`
}

func (q *Queries) MoveForwardToNextPoll(ctx context.Context, id uuid.UUID) (MoveForwardToNextPollRow, error) {
	row := q.db.QueryRowContext(ctx, moveForwardToNextPoll, id)
	var i MoveForwardToNextPollRow
	err := row.Scan(&i.ID, &i.Question, &i.Options)
	return i, err
}
